package users

import (
	"context"

	"connectrpc.com/connect"
	// "google.golang.org/protobuf/types/known/emptypb"

	"github.com/yassi-github/s-progress/domain/entity"
	"github.com/yassi-github/s-progress/log"
	"github.com/yassi-github/s-progress/usecase/users/v1"

	usersv1proto "github.com/yassi-github/s-progress/gen/users/v1"        // generated by protoc-gen-go
	"github.com/yassi-github/s-progress/gen/users/v1/usersv1protoconnect" // generated by protoc-gen-connect-go
)

type server struct {
	logger          log.Handler
	usersInteractor users.Interactor
}

// Returns UsersServiceHandler interface.
// However this function actually returns "server" struct pointer.
// The "server" struct is the method receiver of UsersServiceHandler interface.
func New(logger log.Handler, usersInteractor users.Interactor) usersv1protoconnect.UsersServiceHandler {
	return &server{
		logger:          logger,
		usersInteractor: usersInteractor,
	}
}

// So, we have to implement methods what receiver is the "server" until satisfy UsersServiceHandler interface.
func (s *server) Create(ctx context.Context, req *connect.Request[usersv1proto.CreateRequest]) (*connect.Response[usersv1proto.CreateResponse], error) {
	// req.Msg is usersv1proto.CreateRequest so req.Msg.method() can also be called.
	// server method calls interactor method and convert that return value (entity struct) into protobuf response struct.
	userWithId, err := s.usersInteractor.Create(ctx, req.Msg.GetUserName(), req.Msg.GetEmail(), req.Msg.GetPassword(), req.Msg.GetIsActive(), req.Msg.GetIsSuperuser())
	if err != nil {
		s.logger.ErrorCtx(ctx, "create user error", "err", err)
		return nil, err
	}
	return connect.NewResponse(&usersv1proto.CreateResponse{
		Id:          userWithId.Id,
		UserName:    userWithId.User.UserName,
		Email:       userWithId.User.Email,
		Password:    userWithId.User.Password,
		IsActive:    userWithId.User.IsActive,
		IsSuperuser: userWithId.User.IsSuperuser,
	}), nil
}

func (s *server) FindAll(ctx context.Context, req *connect.Request[usersv1proto.FindAllRequest]) (*connect.Response[usersv1proto.FindAllResponse], error) {
	return nil, nil
}
func (s *server) Find(ctx context.Context, req *connect.Request[usersv1proto.FindRequest]) (*connect.Response[usersv1proto.FindResponse], error) {
	return nil, nil
}
func (s *server) Update(ctx context.Context, req *connect.Request[usersv1proto.UpdateRequest]) (*connect.Response[usersv1proto.UpdateResponse], error) {
	return nil, nil
}
func (s *server) Delete(ctx context.Context, req *connect.Request[usersv1proto.DeleteRequest]) (*connect.Response[usersv1proto.DeleteResponse], error) {
	return nil, nil
}

// converter from entity struct to protobuf struct.
// used if proto response contains user defined type.
func toProtoFindResponse(findResponse *entity.UserWithId) *usersv1proto.FindResponse {
	if findResponse == nil {
		return nil
	}
	return &usersv1proto.FindResponse{
		Id:          findResponse.Id,
		UserName:    findResponse.User.UserName,
		Email:       findResponse.User.Email,
		Password:    findResponse.User.Password,
		IsActive:    findResponse.User.IsActive,
		IsSuperuser: findResponse.User.IsSuperuser,
	}
}
func toProtoFindResponses(findResponses []*entity.UserWithId) []*usersv1proto.FindResponse {
	protoFindResponses := make([]*usersv1proto.FindResponse, 0, len(findResponses))
	for _, findResponse := range findResponses {
		protoFindResponses = append(protoFindResponses, toProtoFindResponse(findResponse))
	}
	return protoFindResponses
}
